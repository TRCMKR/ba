#!/bin/bash
# release
# Usage: ./release "commit message" module patch|minor|major

set -e

if [ $# -ne 3 ]; then
    echo "Usage: $0 \"commit message\" module patch|minor|major"
    exit 1
fi

COMMIT_MSG="$1"
MODULE="$2"
BUMP_TYPE="$3"
TAG_PREFIX="$MODULE/v"

# Check commit message for module tag
if [[ "$COMMIT_MSG" =~ \[([^\]]+)\] ]]; then
    # Message contains [something], check if it matches the module
    MSG_MODULE="${BASH_REMATCH[1]}"
    if [[ "$MSG_MODULE" != "$MODULE" ]]; then
        echo "Error: Module in commit message [$MSG_MODULE] doesn't match parameter module [$MODULE]"
        exit 1
    fi
else
    # No module tag in message, add it
    COMMIT_MSG="[$MODULE] $COMMIT_MSG"
fi

# Get the latest tag for this module
LATEST_TAG=$(git tag -l "${TAG_PREFIX}*" --sort=-v:refname | head -n 1)

if [[ -z "$LATEST_TAG" ]]; then
    # No existing tag, start from 0.0.0
    MAJOR=0
    MINOR=0
    PATCH=0
    echo "No existing tag found for $MODULE, starting from v0.0.0"
else
    # Extract version from tag (e.g., pkg/module/v1.2.3 -> 1.2.3)
    VERSION="${LATEST_TAG#$TAG_PREFIX}"
    MAJOR=$(echo "$VERSION" | cut -d. -f1)
    MINOR=$(echo "$VERSION" | cut -d. -f2)
    PATCH=$(echo "$VERSION" | cut -d. -f3)
    echo "Current version: v$VERSION"
fi

if [[ -z "$MAJOR" || -z "$MINOR" || -z "$PATCH" ]]; then
    echo "Failed to parse version from tag $LATEST_TAG"
    exit 1
fi

# Bump version
case "$BUMP_TYPE" in
    patch)
        PATCH=$((PATCH + 1))
        ;;
    minor)
        MINOR=$((MINOR + 1))
        PATCH=0
        ;;
    major)
        MAJOR=$((MAJOR + 1))
        MINOR=0
        PATCH=0
        ;;
    *)
        echo "Invalid version type: $BUMP_TYPE"
        exit 1
        ;;
esac

NEW_VERSION="$MAJOR.$MINOR.$PATCH"

echo "New version: v$NEW_VERSION"

# Git commit, tag, push
git commit -am "$COMMIT_MSG"
TAG="$MODULE/v$NEW_VERSION"
git tag "$TAG"
git push
git push origin "$TAG"

echo "Released $TAG successfully!"
